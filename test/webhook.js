

// tests for webhook
// Generated by serverless-mocha-plugin
process.env.IS_TEST = true;
process.env.LOG_LEVEL = 1;

const crypto = require('crypto');
const mod = require('../src/handler.js');
const itemStore = require('../src/lib/itemStore.js');
const talkStore = require('../src/lib/talkStore.js');
const objectStore = require('../src/lib/objectStore.js');
const passGenerator = require('../src/lib/passGenerator.js');
const mochaPlugin = require('serverless-mocha-plugin');
const nock = require('nock');
const lambdaWrapper = mochaPlugin.lambdaWrapper;
const expect = mochaPlugin.chai.expect;

const liveFunction = {
  region: process.env.SERVERLESS_REGION,
  lambdaFunction: `${process.env.SERVERLESS_PROJECT}-webhook`,
};

const wrapped = lambdaWrapper.wrap(mod, { handler: 'webhook' });

describe('webhook', () => {
  before((done) => {
//  lambdaWrapper.init(liveFunction); // Run the deployed lambda
    done();
  });

  after((done) => {
    done();
  });

  beforeEach((done) => {
    itemStore.clear().then(() => {
      talkStore.clear().then(() => {
        nock('https://api.line.me')
          .post('/v2/bot/message/reply')
          .reply(200, {});
        nock('https://api.line.me')
          .get(/\/v2\/bot\/message\/[0-9]+\/content/)
          .reply(200, new Buffer( [ 0xff,0xd8,0xff,0xe0,0x00,0x10,0x4a,0x46,0x49,0x46,0x00,0x01,0x01,0x01,0x00,0x48,0x00,0x48,0x00,0x00,0xff,0xdb,0x00,0x43,0x00,0x03,0x02,0x02,0x03,0x02,0x02,0x03,
                                    0x03,0x03,0x03,0x04,0x03,0x03,0x04,0x05,0x08,0x05,0x05,0x04,0x04,0x05,0x0a,0x07,0x07,0x06,0x08,0x0c,0x0a,0x0c,0x0c,0x0b,0x0a,0x0b,0x0b,0x0d,0x0e,0x12,0x10,0x0d,
                                    0x0e,0x11,0x0e,0x0b,0x0b,0x10,0x16,0x10,0x11,0x13,0x14,0x15,0x15,0x15,0x0c,0x0f,0x17,0x18,0x16,0x14,0x18,0x12,0x14,0x15,0x14,0xff,0xc0,0x00,0x0b,0x08,0x00,0x10,
                                    0x00,0x10,0x01,0x01,0x11,0x00,0xff,0xc4,0x00,0x15,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xff,0xc4,0x00,
                                    0x2b,0x10,0x00,0x00,0x03,0x02,0x0c,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x13,0x14,0x15,0x00,0x12,0x09,0x17,0x19,0x22,0x26,0x35,0x39,0x42,0x64,
                                    0x67,0x85,0x94,0x44,0x47,0x62,0x84,0xa6,0xc4,0xe4,0xff,0xda,0x00,0x08,0x01,0x01,0x00,0x00,0x3f,0x00,0x96,0x2e,0x67,0x14,0x65,0x68,0x69,0xc9,0xfb,0x91,0x44,0x3f,
                                    0xd0,0xe8,0x57,0x9e,0x9a,0xab,0xb0,0x45,0x7b,0x72,0xe1,0x6d,0x82,0x0c,0x86,0x14,0x24,0xfe,0x01,0x3e,0x8a,0xa0,0x31,0xe7,0x66,0x89,0xef,0xb2,0x43,0x1c,0xec,0xf1,
                                    0x4f,0xb5,0xbf,0xff,0xd9 ] ));
        done();
      });
    });
  });

  const channelSecret = process.env.CHANNEL_SECRET;
  it('add text message item into db when text message is received', (done) => {
    const sourceId = 'U206d25c2ea6bd87c17655609a1c37cb8';
    const createdAt = 1462629479859;
    const message = {
      id: '325708',
      type: 'text',
      text: 'Hello, world!!!!!!',
    };

    const body = {
      events: [{
        replyToken: 'nHuyWiB7yP5Zw52FIkcQobQuGDXCTA',
        type: 'message',
        timestamp: createdAt,
        source: {
          type: 'group',
          groupId: sourceId,
        },
        message,
      }],
    };

    const signature = crypto.createHmac('sha256', channelSecret).update(JSON.stringify(body)).digest('base64');
    const headers = {
      'Content-Type': 'application/json',
      'X-Line-Signature': signature,
    };

    wrapped.run({ body, headers }, (err, response) => {
      expect(err).to.be.null;
      itemStore.get( { sourceId, createdAt }).then((res) => {
        const count = res.Count;
        expect(count).to.equal(1);

        const item = res.Items[0];
        expect(item).to.deep.equal(Object.assign({}, message, { sourceId, createdAt }));

        done();
      });
    });
  });

  /* // to s3hook
  it('add image message item into db when image message is received', (done) => {
    const sourceId = 'U206d25c2ea6bd87c17655609a1c37cb8';
    const createdAt = 1462629479860;
    const message = {
      id: '325709',
      type: 'image',
    };

    const body = {
      events: [{
        replyToken: 'nHuyWiB7yP5Zw52FIkcQobQuGDXCTA',
        type: 'message',
        timestamp: createdAt,
        source: {
          type: 'group',
          groupId: sourceId,
        },
        message,
      }],
    };

    const signature = crypto.createHmac('sha256', channelSecret).update(JSON.stringify(body)).digest('base64');
    const headers = {
      'Content-Type': 'application/json',
      'X-Line-Signature': signature,
    };

    wrapped.run({ body, headers }, (err, response) => {
      expect(err).to.be.null;
      itemStore.get( { sourceId, createdAt } ).then((res) => {
        const count = res.Count;
        expect(count).to.equal(1);

        const id = message.id;
        const talkId = talkStore.generateId( sourceId );
        const item = res.Items[0];
        const bucket = objectStore.BUCKET_NAME;
        const key_base = `${talkId}/${id}`;
        const objectUrl = `https://s3.amazonaws.com/${bucket}/${key_base}.jpg`;
        const width = 16;
        const height = 16;
        expect(item).to.deep.equal(Object.assign({}, message, { sourceId, createdAt, objectUrl, width, height }));
        done();
      });
    });
  });
  */

  /* // to s3 hook
  it('add video message item into db when video message is received', (done) => {
    const sourceId = 'U206d25c2ea6bd87c17655609a1c37cb8';
    const createdAt = 1462629479861;
    const message = {
      id: '325710',
      type: 'video',
    };

    const body = {
      events: [{
        replyToken: 'nHuyWiB7yP5Zw52FIkcQobQuGDXCTA',
        type: 'message',
        timestamp: createdAt,
        source: {
          type: 'group',
          groupId: sourceId,
        },
        message,
      }],
    };

    const signature = crypto.createHmac('sha256', channelSecret).update(JSON.stringify(body)).digest('base64');
    const headers = {
      'Content-Type': 'application/json',
      'X-Line-Signature': signature,
    };

    wrapped.run({ body, headers }, (err, response) => {
      expect(err).to.be.null;
      itemStore.get( {sourceId, createdAt } ).then((res) => {
        const count = res.Count;
        expect(count).to.equal(1);

        const id = message.id;
        const talkId = talkStore.generateId( sourceId );
        const item = res.Items[0];
        const bucket = objectStore.BUCKET_NAME;
        const key_base = `${talkId}/${id}`;
        const objectUrl = `https://s3.amazonaws.com/${bucket}/${key_base}.mp4`;
        expect(item).to.deep.equal(Object.assign({}, message, { sourceId, createdAt, objectUrl }));

        done();
      });
    });
  });
  */

  it('ignore audio message', (done) => {
    const sourceId = 'U206d25c2ea6bd87c17655609a1c37cb8';
    const createdAt = 1462629479861;
    const message = {
      id: '325710',
      type: 'audio',
    };

    const body = {
      events: [{
        replyToken: 'nHuyWiB7yP5Zw52FIkcQobQuGDXCTA',
        type: 'message',
        timestamp: createdAt,
        source: {
          type: 'group',
          groupId: sourceId,
        },
        message,
      }],
    };

    const signature = crypto.createHmac('sha256', channelSecret).update(JSON.stringify(body)).digest('base64');
    const headers = {
      'Content-Type': 'application/json',
      'X-Line-Signature': signature,
    };

    wrapped.run({ body, headers }, (err, response) => {
      expect(err).to.be.not.null;
      expect(err).to.be.equal('Unsupported message type: audio');

      done();
    });
  });

  it('ignore location message', (done) => {
    const sourceId = 'U206d25c2ea6bd87c17655609a1c37cb8';
    const createdAt = 1462629479861;
    const message = {
      id: '325710',
      type: 'location',
    };

    const body = {
      events: [{
        replyToken: 'nHuyWiB7yP5Zw52FIkcQobQuGDXCTA',
        type: 'message',
        timestamp: createdAt,
        source: {
          type: 'group',
          groupId: sourceId,
        },
        message,
      }],
    };

    const signature = crypto.createHmac('sha256', channelSecret).update(JSON.stringify(body)).digest('base64');
    const headers = {
      'Content-Type': 'application/json',
      'X-Line-Signature': signature,
    };

    wrapped.run({ body, headers }, (err, response) => {
      expect(err).to.be.not.null;
      expect(err).to.be.equal('Unsupported message type: location');

      done();
    });
  });

  it('add multi messages item into db when mult messages are received', (done) => {
    const events = [{
      replyToken: 'nHuyWiB7yP5Zw52FIkcQobQuGDXCTB',
      type: 'message',
      timestamp: 1462629479859,
      source: {
        type: 'group',
        groupId: 'U206d25c2ea6bd87c17655609a1c37cb8',
      },
      message: {
        id: '325708',
        type: 'text',
        text: 'first message',
      },
    },
      {
        replyToken: 'nHuyWiB7yP5Zw52FIkcQobQuGDXCTA',
        type: 'message',
        timestamp: 1462629479860,
        source: {
          type: 'group',
          groupId: 'U206d25c2ea6bd87c17655609a1c37cb8',
        },
        message: {
          id: '325709',
          type: 'text',
          text: 'second message',
        },
      }];
    const body = { events };

    const signature = crypto.createHmac('sha256', channelSecret).update(JSON.stringify(body)).digest('base64');
    const headers = {
      'Content-Type': 'application/json',
      'X-Line-Signature': signature,
    };

    let callbackCount = 0;
    wrapped.run({ body, headers }, (err, response) => {
      expect(err).to.be.null;

      callbackCount += 1;
      if (callbackCount === events.length) {
        itemStore.getAll().then((res) => {
          const count = res.Count;
          expect(count).to.equal(2);

          const item0 = res.Items[0];
          const expectedItem0 = Object.assign({}, events[0].message, { sourceId: events[0].source.groupId, createdAt: events[0].timestamp });
          expect(item0).to.deep.equal(expectedItem0);

          const item1 = res.Items[1];
          const expectedItem1 = Object.assign({}, events[1].message, { sourceId: events[1].source.groupId, createdAt: events[1].timestamp });
          expect(item1).to.deep.equal(expectedItem1);

          done();
        });
      }
    });
  });

  it('add text message item into db when text message is sent from user', (done) => {
    const sourceId = 'cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx';
    const createdAt = 1462629479859;
    const message = {
      id: '325708',
      type: 'text',
      text: 'Hello, world!!!!!!',
    };

    const body = {
      events: [{
        replyToken: 'nHuyWiB7yP5Zw52FIkcQobQuGDXCTA',
        type: 'message',
        timestamp: createdAt,
        source: {
          type: 'user',
          userId: sourceId,
        },
        message,
      }],
    };

    const signature = crypto.createHmac('sha256', channelSecret).update(JSON.stringify(body)).digest('base64');
    const headers = {
      'Content-Type': 'application/json',
      'X-Line-Signature': signature,
    };

    wrapped.run({ body, headers }, (err, response) => {
      expect(err).to.be.not.null;
      expect(err).to.be.equal('Unsupported source type: user');

      done();
    });
  });

  it('add text message item into db when text message is sent from room', (done) => {
    const sourceId = 'cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx';
    const createdAt = 1462629479859;
    const message = {
      id: '325708',
      type: 'text',
      text: 'Hello, world!!!!!!',
    };

    const body = {
      events: [{
        replyToken: 'nHuyWiB7yP5Zw52FIkcQobQuGDXCTA',
        type: 'message',
        timestamp: createdAt,
        source: {
          type: 'room',
          roomId: sourceId,
        },
        message,
      }],
    };

    const signature = crypto.createHmac('sha256', channelSecret).update(JSON.stringify(body)).digest('base64');
    const headers = {
      'Content-Type': 'application/json',
      'X-Line-Signature': signature,
    };

    wrapped.run({ body, headers }, (err, response) => {
      expect(err).to.be.not.null;
      expect(err).to.be.equal('Unsupported source type: room');

      done();
    });
  });

  it('create talk item when join event is received from group', (done) => {
    const sourceId = 'U206d25c2ea6bd87c17655609a1c37cb8';
    const createdAt = 1462629479859;
    const events = [{
      replyToken: 'nHuyWiB7yP5Zw52FIkcQobQuGDXCTA',
      type: 'join',
      timestamp: createdAt,
      source: {
        type: 'group',
        groupId: sourceId,
      },
    }];

    const body = { events };
    const signature = crypto.createHmac('sha256', channelSecret).update(JSON.stringify(body)).digest('base64');
    const headers = {
      'Content-Type': 'application/json',
      'X-Line-Signature': signature,
    };

    wrapped.run({ body, headers }, (err, {talkId, passHash, updateToken}) => {
      expect(err).to.be.null;
      talkStore.get({ talkId }).then((res) => {
        const count = res.Count;
        expect(count).to.equal(1);

        const talk = res.Items[0];
        const expectedTalk = {
          talkId,
          sourceId,
          passHash,
          updateToken,
          createdAt,
          updateCount: 0,
        };
        expect(talk).to.deep.equal(expectedTalk);

        done();
      });
    });
  });

  it('ignore join event from room', (done) => {
    const sourceId = 'U206d25c2ea6bd87c17655609a1c37cb8';
    const createdAt = 1462629479859;
    const events = [{
      replyToken: 'nHuyWiB7yP5Zw52FIkcQobQuGDXCTA',
      type: 'join',
      timestamp: createdAt,
      source: {
        type: 'room',
        roomId: sourceId,
      },
    }];

    const body = { events };
    const signature = crypto.createHmac('sha256', channelSecret).update(JSON.stringify(body)).digest('base64');
    const headers = {
      'Content-Type': 'application/json',
      'X-Line-Signature': signature,
    };

    wrapped.run({ body, headers }, (err, response) => {
      expect(response).to.be.undefined;
      done();
    });
  });

  it('ignore follow event', (done) => {
    const sourceId = 'U206d25c2ea6bd87c17655609a1c37cb8';
    const createdAt = 1462629479859;
    const events = [{
      replyToken: 'nHuyWiB7yP5Zw52FIkcQobQuGDXCTA',
      type: 'follow',
      timestamp: createdAt,
      source: {
        type: 'user',
        userId: sourceId,
      },
    }];

    const body = { events };
    const signature = crypto.createHmac('sha256', channelSecret).update(JSON.stringify(body)).digest('base64');
    const headers = {
      'Content-Type': 'application/json',
      'X-Line-Signature': signature,
    };

    wrapped.run({ body, headers }, (err, response) => {
      expect(response).to.be.undefined;
      done();
    });
  });

  it('reply page url when url command is received', (done) => {
    const sourceId = 'U206d25c2ea6bd87c17655609a1c37cb8';
    const createdAt = 1462629479859;
    const message = {
      id: '325708',
      type: 'text',
      text: '@uRl',
    };

    const body = {
      events: [{
        replyToken: 'nHuyWiB7yP5Zw52FIkcQobQuGDXCTA',
        type: 'message',
        timestamp: createdAt,
        source: {
          type: 'group',
          groupId: sourceId,
        },
        message,
      }],
    };

    const signature = crypto.createHmac('sha256', channelSecret).update(JSON.stringify(body)).digest('base64');
    const headers = {
      'Content-Type': 'application/json',
      'X-Line-Signature': signature,
    };

    wrapped.run({ body, headers }, (err, response) => {
      expect(err).to.be.null;
      itemStore.get( { sourceId, createdAt } ).then((res) => {
        done();
      });
    });
  });

  it('reply confirm when pass command is received', (done) => {
    const sourceId = 'U206d25c2ea6bd87c17655609a1c37cb8';
    const createdAt = 1462629479859;
    const passPhrase = 'aabbccdd';
    const message = {
      id: '325708',
      type: 'text',
      text: `@Pass ${passPhrase}`,
    };

    const body = {
      events: [{
        replyToken: 'nHuyWiB7yP5Zw52FIkcQobQuGDXCTA',
        type: 'message',
        timestamp: createdAt,
        source: {
          type: 'group',
          groupId: sourceId,
        },
        message,
      }],
    };

    const signature = crypto.createHmac('sha256', channelSecret).update(JSON.stringify(body)).digest('base64');
    const headers = {
      'Content-Type': 'application/json',
      'X-Line-Signature': signature,
    };

    const talkId = talkStore.generateId( sourceId );
    const passHash = passGenerator.hash( passPhrase, talkId );
    const updateToken = '123456789';
    talkStore.put({
      talkId,
      sourceId,
      createdAt,
      passHash,
      updateToken,
      updateCount: 0,
    }).then( ()=>{
      wrapped.run({ body, headers }, (err, response) => {
        expect(err).to.be.null;
        expect(response.type).to.equal('updatePass');
        expect(response.passHash).to.equal(passHash);
        talkStore.get( { talkId } ).then( talkResponse => {
          const count = talkResponse.Count;
          expect(count).to.equal(1);

          const talk = talkResponse.Items[0];
          expect(talk.updateToken).to.equal(response.updateToken);
          done();
        })
      });
    });
  });

  it('update passHash and updateToken when valid passUpdate postback event which has passHash is received', (done) => {
    const sourceId = 'U206d25c2ea6bd87c17655609a1c37cb8';
    const createdAt = 1462629479859;
    const postback = {
      data: "{\"type\":\"updatePass\",\"passHash\":\"4l2iPHiFddehdtoUDW3na2d0+LSCIWKCRIGJsqNIHlI=\",\"updateToken\":\"1Dezj+eP+9epic+kIE4W64F41GrcmZeEjKAjNqGGDjs=\"}"
    };

    const body = {
      events: [{
        replyToken: 'nHuyWiB7yP5Zw52FIkcQobQuGDXCTA',
        type: "postback",
        timestamp: createdAt,
        source: {
          type: "group",
          groupId: sourceId,
        },
        postback,
      }],
    };

    const signature = crypto.createHmac('sha256', channelSecret).update(JSON.stringify(body)).digest('base64');
    const headers = {
      'Content-Type': 'application/json',
      'X-Line-Signature': signature,
    };

    const passHash = '-';
    const updateToken = '1Dezj+eP+9epic+kIE4W64F41GrcmZeEjKAjNqGGDjs=';
    const talkId = talkStore.generateId( sourceId );
    talkStore.put({
      talkId,
      sourceId,
      createdAt,
      passHash,
      updateToken,
      updateCount: 0,
    }).then( ()=>{
      wrapped.run({ body, headers }, (err, response) => {
        expect(err).to.be.null;
        talkStore.get( { talkId } ).then( (talkResponse) => {
          const count = talkResponse.Count;
          expect(count).to.equal(1);

          const talk = talkResponse.Items[0];
          const newPassHash = talk.passHash;
          const newPassToken = talk.updateToken;
          expect(newPassHash).to.equal('4l2iPHiFddehdtoUDW3na2d0+LSCIWKCRIGJsqNIHlI=');
          expect(newPassToken).to.not.equal(updateToken);
          done();
        });
      });
    });
  });

  it('update only updateToken when valid passUpdate postback event which doesn\'t have passHash is received', (done) => {
    const sourceId = 'U206d25c2ea6bd87c17655609a1c37cb8';
    const createdAt = 1462629479859;
    const postback = {
      data: "{\"type\":\"updatePass\",\"updateToken\":\"1Dezj+eP+9epic+kIE4W64F41GrcmZeEjKAjNqGGDjs=\"}"
    };

    const body = {
      events: [{
        replyToken: 'nHuyWiB7yP5Zw52FIkcQobQuGDXCTA',
        type: "postback",
        timestamp: createdAt,
        source: {
          type: "group",
          groupId: sourceId,
        },
        postback,
      }],
    };

    const signature = crypto.createHmac('sha256', channelSecret).update(JSON.stringify(body)).digest('base64');
    const headers = {
      'Content-Type': 'application/json',
      'X-Line-Signature': signature,
    };

    const passHash = '-';
    const updateToken = '1Dezj+eP+9epic+kIE4W64F41GrcmZeEjKAjNqGGDjs=';
    const talkId = talkStore.generateId( sourceId );
    talkStore.put({
      talkId,
      sourceId,
      createdAt,
      passHash,
      updateToken,
      updateCount: 0,
    }).then( ()=>{
      wrapped.run({ body, headers }, (err, response) => {
        expect(err).to.be.null;
        talkStore.get( { talkId } ).then( (talkResponse) => {
          const count = talkResponse.Count;
          expect(count).to.equal(1);

          const talk = talkResponse.Items[0];
          const newPassHash = talk.passHash;
          const newPassToken = talk.updateToken;
          expect(newPassHash).to.equal(passHash);
          expect(newPassToken).to.not.equal(updateToken);
          done();
        });
      });
    });
  });

  it('reject event when invalid passUpdate postback event is received', (done) => {
    const sourceId = 'U206d25c2ea6bd87c17655609a1c37cb8';
    const createdAt = 1462629479859;
    const postback = {
      data: "{\"type\":\"updatePass\",\"updateToken\":\"1Dezj+eP+9epic+kIE4W64F41GrcmZeEjKAjNqGGDjs=\"}"
    };

    const body = {
      events: [{
        replyToken: 'nHuyWiB7yP5Zw52FIkcQobQuGDXCTA',
        type: "postback",
        timestamp: createdAt,
        source: {
          type: "group",
          groupId: sourceId,
        },
        postback,
      }],
    };

    const signature = crypto.createHmac('sha256', channelSecret).update(JSON.stringify(body)).digest('base64');
    const headers = {
      'Content-Type': 'application/json',
      'X-Line-Signature': signature,
    };

    const passHash = '-';
    const updateToken = '1Dezj+eP+9epic+kIE4W64F41GrcmZeEjKAjNqGGDjd=';
    const talkId = talkStore.generateId( sourceId );
    talkStore.put({
      talkId,
      sourceId,
      createdAt,
      passHash,
      updateToken,
      updateCount: 0,
    }).then( ()=>{
      wrapped.run({ body, headers }, (err, response) => {
        expect(err).to.be.not.null;
        expect(err.message).to.be.equal('Invalid updateToken to update passHash: 1Dezj+eP+9epic+kIE4W64F41GrcmZeEjKAjNqGGDjs=');

        done();
      });
    });
  });

});
